//GNU General Public License v3

#include <stdio.h>
#include <math.h>

//Лабораторная №4. Вариант №11
/* 1. Дана целочисленная квадратная матрица. Определить:
сумму элементов в тех столбцах, которые не содержат отрицательных элементов;
минимум среди сумм элементов диагоналей, параллельных побочной диагонали матрицы
Каждый пункт задания оформить в виде отдельной функции.
* 2. Вычислить и напечатать сумму членов бесконечного ряда для заданного значения x с точностью до эпсель = 0.00001: Сигма n=0/infinity (x^(2n+1))/(2n+1) */

const int N = 5;
const int M = 5;

void sum(int mas[N][M]) {
	//Выводит сумму элементов в тех столбцах, которые не содержат отрицательных элементов
	int i,j;
	int otric = 0; //1, если в столбце есть отрицательные элементы
	int sum = 0;
	for(i = 0; i < N; i++) {
		for(j = 0; j < M; j++) {
			if(mas[j][i] < 0)
				otric = 1;
			sum += mas[j][i];
		}
		if(!otric)
			printf("\nСумма элементов %d столбца: %d", i+1, sum);
		otric = 0;
		sum = 0;
	}
}

void getmas(int mas[N][M]) {
	int i,ii;
	for (i = 0; i < N; i++) {
		printf("Введите %d строку (%d чисел): ",i+1,M);
		for(ii = 0; ii < M; ii++) {
			scanf("%d",&mas[i][ii]);
		}
	}
}

int pobmin(int mas[N][M]) {
	//Вычисляет минимум среды сумм элементов диагоналей, параллельных побочной диагонали матрицы
	int i,j;
	int k; //Смещение относительно побочной диагонали
	int sum = 0; //Сумма текущей диагонали
	int min_sum = 999999999; //Минимум среди сумм
	for (k = -N; k < N-2-1; k++) { //Обход диагоналей
	//printf("\nПобочная диагональ: ");
		if(k != -2) { //т.к в таком случае у нас побочная диагональ
			for(i = 0; i < N; i++) {
				j = (N+k)-i+1;
				if (j < N && j >= 0) {
					sum += mas[i][j];
					//printf("k = %d; mas[%d][%d]  ",k,i,j);
				}
				
			}
			if(min_sum > sum)
				min_sum = sum;
			sum = 0;
		}
	}
	return min_sum;
}

/*void printmas(int mas[N][M]) {
	int i,ii;
	for (i = 0; i < N; i++) {
		printf("\n%d строка: ",i+1);
		for(ii = 0; ii < M; ii++) {
			printf(" %d ",mas[i][ii]);
		}
	}
}*/

double summa(double x) {
	//Вычисляет сумму членов бесконечного ряда для заданного значения x с точностью до эпсель = 0.00001: 2 * Сигма n=0/infinity (x^(2n+1))/(2n+1)
	if(!(fabs(x) < 1)) {
		printf("\nЗначене x должно удовлетворять условию |x|<1!");
		return 0;
	}
	double e = 0.00001; //Необходимая точность
	double sum = 0;
	double prev; //Предедущее слогаемое
	double current; //Текущее слогаемое
	int n = 0;
	int i;
	//При вычисленнии внесём двойку под сигму для удобства
	do {
		prev = current;
		current = (2*pow(x,2*n+1))/(2*n+1);
		sum += current;
		n++;
	}
	while(fabs(current - prev) > e);
	return sum;
}

int main() {
	int mas[N][M];
	double x;
	
	getmas(mas); //Запрашиваем ввод массива
	//printmas(mas);
	sum(mas); //Считаем сумму столбцов, где нет отрицательных символов
	printf("\nМинимум среды сумм элементов диагоналей, параллельных побочной диагонали матрицы = %d",pobmin(mas));
	
	printf("Программа вычисляет сумму членов бесконечного ряда для заданного значения x с точностью до эпсель = 0.00001: 2 * Сигма n=0/infinity (x^(2n+1))/(2n+1))\nВведите x: ");
	scanf("%lf",&x);
	printf("\nСумма членов ряда = %lf",summa(x));
	
	return 0;
}
